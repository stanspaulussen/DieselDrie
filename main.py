"""
main.py
Minor Programming: Programming Theory
By: Pauline van Lieshout, Jari Hoffman and Stans Paulussen

This file allows user to run the different algorithms, and choose certain
properties like which map to use, track amount and if relevant, the number
of loops the algorithm makes.
"""

from code.classes import grid, station, track
from code.visualisation import visualise
from code.algorithms import randomise, greedy, greedy_lookahead, random_greedy, depth_first, depth_first_2, depth_first_random
import csv
import time

def prompt_loops():
    """
    Function prompts user for loop amount in random algorithms.
    """
    while True:
        try:
            return int(input("How many loops should the algorithm do?\n"))
        except ValueError:
            print("That input is incorrect, please try again and type an integer")
            continue
        else:
            break

if __name__ == "__main__":

    # prompts user to choose which map to use (Holland/the Netherlands)
    while True: 
        try: 
            data = int(input("Which map would you like to use? Choose '1' for Holland or '2' for the Netherlands.\n"))
        except ValueError:
            print("That input is incorrect, please try again and type an integer")
            continue
        else:
            break

    # prompts user to choose how many tracks should be generated by the algorithm
    while True:
        try:
            track_amount = int(input("How many tracks should the algorithm make?\n"))
        except ValueError:
            print("That input is incorrect, please try again and type an integer")
            continue
        else:
            break

    # creates a grid from our data
    test_grid = grid.Grid(data)
    
    # choose the algorithm
    print("Choose your algorithm:")
    print("1: Random")
    print("2: Greedy")
    print("3: Random Greedy")
    print("4: Greedy with Lookahead")
    print("5: Depth First")
    print("6: Depth First 2.0")
    print("7: Depth First 2.0 Random")

    choice = False

    # prompts user to choose an algorithm
    while choice == False:

        while True:
            try: 
                num = int(input("number of chosen algorithm: "))
            except ValueError:
                print("That input is incorrect, please try again and type an integer")
                continue 
            else:
                break 
        
        # random algorithm
        if num == 1:
            choice = True
            loop_amount = prompt_loops()
            algorithm = randomise.Random(test_grid, loop_amount, track_amount, data)
        # greedy without lookahead algorithm
        elif num == 2:
            choice = True
            algorithm = greedy.Greedy(test_grid, data, track_amount)
        # random greedy algorithm
        elif num == 3: 
            choice = True
            loop_amount = prompt_loops()
            algorithm = random_greedy.Random_greedy(test_grid, data, track_amount, loop_amount)
        # greedy with lookahead algorithm
        elif num == 4:
            choice = True
            algorithm = greedy_lookahead.Greedy_Lookahead(test_grid, data, track_amount)
        # depth first algorithm
        elif num == 5:
            choice = True
            algorithm = depth_first.Depth_first(test_grid, data, track_amount)
        # depth first 2 algorithm
        elif num == 6:
            choice = True
            algorithm = depth_first_2.Depth_first_2(test_grid, data, track_amount)
        # random depth first algorithm
        elif num == 7:
            choice = True
            algorithm = depth_first_random.Depth_first_random(test_grid, data, track_amount)
        # invalid input
        else: 
            print("That input is incorrect, please try again")
            
        # starting time
        start = time.time()

        # runs algorithm
        algorithm.run()

        # makes sure the random algorithms show their best grid
        if num == 1 or num == 3:
            test_grid = algorithm.best_grid
        else: 
            test_grid = algorithm.grid

    # timing the algorithm
    end = time.time()
    duration = end - start
    
    # prints information the grid and its duration and quality
    print(f"The algorithm has finished in {duration} seconds, this is your score:")
    print(test_grid.get_quality())
    print("This is what the solution looks like:")
    print(test_grid)
    visualise.graph(test_grid)